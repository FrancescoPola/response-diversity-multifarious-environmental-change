---
title: "Empirical example for: Measuring the response diversity of ecological communities experiencing multifarious environmental change."
author: "Francesco Polazzo, Romana Limberger, Frank Pennekamp, Samuel Ross, Gavin Simpson, Owen Petchey"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    code_folding: hide
    keep_md: yes
editor_options: 
  markdown: 
    wrap: 72
---

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      include = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE)
```

```{r results='hide', echo=FALSE}
rm(list = ls())
library(plotly)
library(tidyverse)
library(here)
library(patchwork)
library(DT)
library(mgcv)
library(gratia)
library(rlang)
library(vctrs)
library(scales)
library(broom)
library(reshape2)
library(ggtext)
library(ggsci)
library(ggpubr)
source.files <- list.files(here("r"), full.names = TRUE)
sapply(source.files, source, .GlobalEnv)
theme_set(theme_classic(base_size = 20))
```

# Introduction 

This is example illustrates how to apply our new method to calculate the response diversity in a multifarious environmental change context. We will use a dataset of growth rates (our performance trait) of 5 species of phytoplankton factorially grown at 6 different temperatures and 12 phosphate  concentrations and their combination in a 1-month experiment. The original dataset is associated with the publication [Bestion et al 2018](https://aslopubs.onlinelibrary.wiley.com/doi/full/10.1002/lol2.10096), and the dataset is publicly available on [Zenodo](https://zenodo.org/records/1247453).
We will apply step by step the procedure described in the main text of the publication and shown with simulated data in the Appendix 1.

In this document we will:

- Model species response surfaces using GAMs
- Calculate partial derivatives of one species growth rate to each of the environmental drivers separately 
- Simulate an environmental change scenario that will give us the direction of the environmental change
- Calculate the *response diversity* of an hypothetical community assemble by putting together the 5 species of phytoplankton
- Calculate *Response Capacity* of two hypothetical communities of 3 species each, assemble by randomly selecting 3 species from the 5 species of phytoplankton

Some of the figures generated in this document are also used in the main text of the publication. To reproduce all the figures shown in the main text, please refer to the R script called "Figure_empirical.R" available in the [GitHub repository](https://github.com/FrancescoPola/response-diversity-multifarious-environmental-change)


### Loding data and plotting species responses
```{r ciliates, fig.cap='Species responses to the environmental drivers. (a). Species responses to temperature (°C). (b). Species responses to light intensity', fig.align="center", fig.height=20, fig.width=30, results='hide'}
df <- read_csv(here("Data/Growth rate data.csv"))
head(df)


## Look at sp responses
fig1 <- df %>% 
  ggplot( aes(x = temperature, y = (mumax),  col = as.factor(Phosphate_concentration))) +
  geom_point()+
  geom_smooth(se = FALSE) +
  facet_wrap(~SpeciesName, ncol = 5) +
  theme_bw(base_size = 20)+
  scale_color_viridis_d(end = 0.2,begin = 0.9, option = 'inferno') +
  labs(x = "Temperature °C", y = "growth rate", tag = "(a)")


fig2 <- df %>% 
  ggplot( aes(x = Phosphate_concentration, y = (mumax), col = as.factor(temperature))) +
  geom_point()+
  geom_smooth(se = FALSE) +
  facet_wrap(~SpeciesName, ncol = 5)+ 
  theme_bw(base_size = 20)+
  scale_color_viridis_d(end = 0.2,begin = 0.9, option = 'inferno') +
  labs(x = "Phosphate_concentration (μmol L−1)", y = "growth rate", tag = "(b)") 


fig1 / fig2
```


### Fittig GAMs on empirical data
```{r, echo=FALSE, results='hide'}

# Create new env data
new_data <- expand_grid(E1 = seq(15, 40, by= 0.5),
                        E2 = seq(0.01, 40, by= 0.5))


## fit GAMs and get predicted rates
names(df)
nested_gams <- df[,c(1:3,8)] %>% dplyr::rename(E1 = "temperature",
                                               E2 = "Phosphate_concentration") %>% 
  dplyr::mutate(E2 = as.numeric(gsub("%","",as.character(E2)))) %>% 
  nest(cols =-SpeciesName) %>% 
  mutate(
    gams = map(cols, ~ gam(mumax ~ te(E1, E2, k = c(5, 5)),
                           data = .x,
                           method = "REML")),
    predicted = map(gams, ~ predict(.x, newdata = new_data))
  )


# Get gams coefficients
coeff <- nested_gams %>% 
  mutate(coefs = map(gams, tidy, conf.int = TRUE)) %>% 
  unnest(coefs) %>% 
  dplyr::select(c('SpeciesName', 'term', 'p.value'))

DT::datatable(coeff,
              filter="top")


# Get gams glance
nested_gams %>% 
  mutate(results = map(gams, glance), 
         R.square = map_dbl(gams, ~ summary(.)$r.sq))  %>% 
  unnest(results) 


# Creating the dataset with the 2 columns as described above
predicted <- nested_gams %>% unnest(predicted)
rates <- cbind(new_data, predicted[,c(1,4)])
rates <- rates %>%
  relocate(SpeciesName, E1, E2, predicted)
```


```{r results='asis', message=FALSE, warning=FALSE}
knitr::kable(head(rates), col.names = gsub("[.]", " ", names(rates)))

```


### Plotting surface for a single species

```{r surface-fig, fig.cap='Response surface fitted with GAM. High non-linearity.', fig.align="center", fig.height=5, fig.width=12}
# try plotting surface for Colpidium
Ankistrodesmus <- filter(rates, SpeciesName == "Ankistrodesmus")
data <- data.frame(x=Ankistrodesmus$E1,y=Ankistrodesmus$E2,z=Ankistrodesmus$predicted)

Ankistrodesmus_gr <- as.matrix(acast(data, x~y, value.var="z"))

myxticks = c(0.55, 0.5, 1, 2, 4, 6,8 , 10, 20, 40)
axx <- list(
  title = 'Temperature',
  nticks = myxticks,
  ticktext = myxticks
)

myyticks = c(15, 18, 20, 22, 25, 28, 30, 35, 38, 40)
axy <- list(
  title = 'Phosphate concentration',
  nticks = myyticks,
  ticktext = myyticks
)

axz <- list(
  title = 'growth rate',
  nticks = 10
)



x_Ankistrodesmus_gr <- as.numeric(rownames(Ankistrodesmus_gr))
y_Ankistrodesmus_gr <- as.numeric(colnames(Ankistrodesmus_gr))


figAnkistrodesmus_gr <- plot_ly(z = ~Ankistrodesmus_gr) %>% 
  add_surface(contours = list(z = list(show=TRUE, usecolormap=TRUE, project=list(z=TRUE))))%>%
  layout(title = 'Ankistrodesmus', plot_bgcolor = "#e5ecf6", scene = list(xaxis=axx,yaxis=axy,zaxis=axz))

figAnkistrodesmus_gr 


```


# Partial derivatives for a single species

## E1 - Temperature

First, we calculate the partial derivative with respect to the first environmental variable - temperature -
 keeping phosphate concentration constant at 15 μmol L−1.

```{r partialderiv-empirical, fig.cap='Response surface of Ankistrodesmus The  solid line shows at which level of temperature partial derivativ is going to be calculated.', fig.align="center", fig.height=7, fig.width=9}

Ankistrodesmus <- filter(nested_gams, SpeciesName == "Ankistrodesmus")

E1 = as.numeric(unique(df$temperature))
E2 = as.numeric(unique(df$Phosphate_concentration))
refs <- tibble(crossing(E1, E2))
m_Ankistrodesmus <- (Ankistrodesmus$gams[[1]])
my_sp_names <- (Ankistrodesmus$SpeciesName)


# specify env location 
E1_p = c(27.5)
E2_p = c(15)

# data slice through te(x,z) holding z == 0.4
ds_E1 <- data.frame(E1 = evenly(E1, n = 100), E2 = E2_p)


# evaluate te(x,z) at values of x & z
sm_E1 <- smooth_estimates(m_Ankistrodesmus, smooth = "te(E1,E2)", data = ds_E1) |>
  add_confint()


# partial derivatives
pd_E1 <- partial_derivatives(m_Ankistrodesmus, data = ds_E1, type = "central", focal = "E1")

# draw te(x,z)
p1 <- draw(m_Ankistrodesmus, rug = FALSE, dist = 0.5) &
  geom_hline(yintercept = E2_p, size = 1) & labs(title = "Ankistrodesmus", x = "Temperature °C", y = "Phosphate concentration (μmol L−1)") 
p1+  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))
```


Partial effect of temperature on the growth rate of Ankistrodesmus.

```{r partialeffectE1-empirical, fig.cap='Partial effect of temperature on the growth rate of Ankistrodesmus when phosphate concentration is held constant at 15μmol L-1.', fig.align="center", fig.height=7, fig.width=9}
cap_E1 <- expression(Phosphate_concentration == 15)
p2 <- sm_E1|>
  ggplot(aes(x = E1, y = est)) +
  geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.2) +
  geom_line() +
  labs(x = "Temperature °C", y = "Partial effect of T",
       caption = cap_E1, title = "")
p2
```



Partial derivative with respect to temperature on the growth rate of Ankistrodesmus.

```{r partialE1-empirical, fig.cap='Partial derivative with respect to temperature on the growth rate of Ankistrodesmus when phosphate concentration is held constant at 15μmol L-1', fig.align="center", fig.height=7, fig.width=9}

p3 <- pd_E1 |>
  draw() +
  labs(x = "Temperature °C", y = "Partial derivative with respect to T \n on Ankistrodesmus growth rate",
       caption = cap_E1, title = "")
p3

```


## E2 - Phosphate concentration

Second, we calculate the partial derivative with respect to Phosphate concentration
keeping temperature constant at 27.5 °C. 

Response surface of Ankistrodesmus.
```{r partialderivE2-empirical, fig.cap='Response surface of Ankistrodesmus. The solid line shows at which level of phosphate the partial derivative is going to be calculated.', fig.align="center", fig.height=7, fig.width=9}
ds_E2 <- data.frame(E2 = evenly(E2, n = 100), E1 = E1_p)


# evaluate te(x,z) at values of x & z
sm_E2 <- smooth_estimates(m_Ankistrodesmus, smooth = "te(E1,E2)", data = ds_E2) |>
  add_confint()


# partial derivatives
pd_E2 <- partial_derivatives(m_Ankistrodesmus, data = ds_E2, type = "central", focal = "E2")



# draw te(x,z)
p4 <- draw(m_Ankistrodesmus, rug = FALSE, dist = 0.5) &
  geom_vline(xintercept = E1_p, size = 1) & labs(title = "Ankistrodesmus", x = "Temperature", y = "Phosphate concentration (μmol L−1)")
p4+  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))
```



Partial effect of phosphate concentration on the growth rate of Ankistrodesmus 

```{r partialeffectE2-empirical, fig.cap='Partial effect of phosphate concentration on the growth rate of Ankistrodesmus when temperature is held constant at 27.5°C. ', fig.align="center", fig.height=7, fig.width=9}

cap_E2 <- expression(Temperature == 27.5)
p5<- sm_E2 |>
  ggplot(aes(x = E2, y = est)) +
  geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.2) +
  geom_line() +
  labs(x = "Phosphate concentration (μmol L−1)", y = "Partial effect of Phosphate\n concentration (μmol L−1)\n on Ankistrodesmus growth rate", title = "",
       caption = cap_E2)
p5
```

Partial derivative of Ankistrodesmus growth rate with respect to phosphate concentration 

```{r partialE2-empirical, fig.cap='Partial derivative with respect to phosphate concentration when temperature is constant at 27.5°C.', fig.align="center", fig.height=7, fig.width=9}
p6 <- pd_E2 |>
  draw() +
  labs(x = "Phosphate concentration (μmol L−1)", y = "Partial derivative with respect to Phosphate concentration (μmol L−1)\n on Ankistrodesmus growth rate",caption = cap_E2, title = "")
p6
```

### Plot surface and partial derivatives

Plot the two partial derivatives and relative effects


```{r summary-empirical, fig.cap='Summary plot of Ankistrodesmus (a) response surface of Ankistrodesmus (b) Partial effect of temperature on the growth rate of Ankistrodesmus when phosphate concentration is held constant at 15 (μmol L−1). (c) Partial derivative with respect to temperature when phosphate concentration is held constant at 15 (μmol L−1). (d) Partial effect of phosphate concentration on the growth rate of Ankistrodesmus when temperature is held constant at 27.5°C (e) Partial derivative with respect to phosphate concentration when temperature is held constant at 27.5°C.', fig.align="center", fig.height=12, fig.width=18}
p1 <-  draw(m_Ankistrodesmus, rug = FALSE, dist = 0.5) &
  geom_hline(yintercept = E2_p, size =1) &
  geom_vline(xintercept = E1_p, size = 1) &
  labs(x = "Temperature °C", y = "Phosphate concentration (μmol L−1)",title = "", caption = '', tag = "(a)") 

p1 <-p1 +  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))
p2 <- p2 + labs(tag = "(b)")
p3 <- p3 + labs(tag = "(c)")
p4 <- p4 + labs(tag = "(d)")
p5 <- p5 + labs(tag = "(e)")
p6 <- p6 + labs(tag = "(f)")
p_partials <- wrap_plots(p1, p2, p3, p5, p6)
p_partials
```



# Directional deriviatives

To calculate the directional derivatives for all spp used in the
experiment, we first create a time series with phosphate concentration
and temperature changing randomly over time, which gives us the
direction of the environmental change, and then we calculate partial
derivatives.

```{r, echo=FALSE, results='hide'}
# Create a time series with E1 and E2 changing randomly over time
(refs <- tibble(sample(new_data$E1, 50), sample(new_data$E2, 50)) %>% 
   dplyr::rename(E1 = "sample(new_data$E1, 50)", E2 = "sample(new_data$E2, 50)"))
m_list <- (nested_gams$gams)
my_sp_names <- (nested_gams$SpeciesName)
time <-  as.data.frame(seq.int(nrow(refs)))

(pd_list <- modify_depth(m_list, 1, ~ get_partials(., refs)))

(pd_list <- Map(cbind, pd_list, time = time))

# from list to tibble
(pd_spp <- tibble(
  E1_ref = map(pd_list, "E1"),
  E2_ref = map(pd_list, "E2"),
  pd_E1 = map(pd_list, "pd_E1"),
  pd_E2 = map(pd_list, "pd_E2"),
  time = map(pd_list, "time")) %>% 
    dplyr::mutate(sp = my_sp_names) %>% 
    relocate(sp, time, E1_ref, E2_ref, pd_E1, pd_E2) %>% 
    unnest(time, E1_ref, E2_ref, pd_E1, pd_E2))

```

Time series of temperature and phosphate concentration and changing over
time.

```{r RD-empirical, fig.cap='Time series of (a) temperature and (b) phosphate concentration changing over time.', fig.align="center", fig.height=3, fig.width=8}

# plotting env change over time

p_E1 <- pd_spp %>% 
  ggplot(aes(x = time, y = E1_ref)) + geom_line(col = "blue", size = 1.5) +
  theme_classic() +
  labs(tag = "(a)", y = "Temperature (°C)")

p_E2 <- pd_spp %>% 
  ggplot(aes(x = time, y = E2_ref)) + geom_line(col = "red", size = 1.5)+
  theme_classic()+
  labs(tag = "(b)", y = "Phosphate concentration (μmol L−1)")

p_E1 + p_E2

```



Table with calculated partial derivatives for each sp at different times
(only first 6 rows shown).

```{r results='asis', message=FALSE, warning=FALSE}
knitr::kable(head(pd_spp), col.names = gsub("[.]", " ", names(pd_spp)))

```

## Calculating response diversity for a community (all 5 spp used in the experiment)

First, we need to calculate the directional derivatives in the trajectory
of the env change.

```{r, echo=FALSE, results='hide'}
(dd_spp <- pd_spp %>% transform( nxt_value_E1 = c(E1_ref[-1], NA)) %>% 
    transform(nxt_value_E2 = c(E2_ref[-1], NA)) %>% 
    dplyr::mutate(del_E1 = nxt_value_E1 - E1_ref,
                  del_E2 = nxt_value_E2 - E2_ref,
                  unit_vec_mag =  sqrt(del_E1^2 + del_E2^2),
                  uv_E1 = del_E1 / unit_vec_mag,
                  uv_E2 = del_E2 / unit_vec_mag,
                  dir_deriv = pd_E1 * uv_E1 +  pd_E2 * uv_E2) %>% 
      filter(time != max(time)))
```

```{r results='asis', message=FALSE, warning=FALSE}
knitr::kable(head(dd_spp), col.names = gsub("[.]", " ", names(dd_spp)))

```

Then we can calculate response diversity for an hypothetical community
containing all the species tested i this experiment.

```{r, echo=FALSE, results='hide'}
# reduce the dataframe and keep only what we need

red_spp <- dd_spp %>%  dplyr::select(sp, time, E1_ref, E2_ref, dir_deriv) 

# from long to wide
(rdiv_sim <- red_spp %>% 
  spread( sp, dir_deriv))

rdiv_sim[is.na(rdiv_sim)] <- 0
names(rdiv_sim)
#rdiv_sim <- rdiv_sim[,c(1,2,3,13:19)] # removing useless columns

# actual calculation for only the same species used above
rdiv_sim$rdiv<-apply(rdiv_sim[,c(4:8)], 1, resp_div, sign_sens = F)
rdiv_sim$sign<-apply(rdiv_sim[,c(4:8)], 1, resp_div, sign_sens = T)
rdiv_sim$Med<-median(rdiv_sim$rdiv)
rdiv_sim$Med_sing<-median(rdiv_sim$sign)
rdiv_sim
```

```{r results='asis', message=FALSE, warning=FALSE}
knitr::kable(head(rdiv_sim), col.names = gsub("[.]", " ", names(rdiv_sim)))

```

Plot response diversity over time

```{r RDempiricalplot, fig.cap='Directional derivatives and response diversity with known trajectory of env change. a. Species directional derivatives over time. b. Response diversity measured as similarity-based diversity metric. c. Response diversity measured as divergence (sign sensitive). ', fig.align="center", fig.height=12, fig.width=10}

p_dd <- ggplot(data = red_spp, mapping = aes(x = time, y = dir_deriv, col = sp)) +
  geom_line() +
  geom_hline(yintercept = 0, linetype = "dashed")+
  theme_classic() + 
   labs(x = "time",y = "Directional derivative",tag = "a)") + 
  #geom_point(size=0.5) +
  geom_line() + theme_bw() + geom_hline(yintercept = 0, linetype= "dashed")

p_rd <- ggplot(data = rdiv_sim, mapping = aes(x = time, y = rdiv)) +
  geom_line() +
  theme_classic(base_size = 12) + 
  labs(x = NULL,y = "dissimilarity (derivatives)",tag = "(b)") + 
  geom_hline(yintercept = rdiv_sim$Med,lty=2) +
  geom_line() + 
  geom_richtext(x = 10,
                mapping = aes(y = rdiv_sim$Med + 0.25),
                size=4.5,
                label.color = NA,
                label = paste("RDiv^Med =",paste0(round(rdiv_sim$Med,digits = 2))))

p_sign <- ggplot(data = rdiv_sim, mapping = aes(x = time, y = sign)) +
  geom_line() +
  theme_classic(base_size = 12)+
  labs(x = "time",y = "Divergence", tag = "(c)") + 
  geom_hline(yintercept = rdiv_sim$Med_sing,lty=2) +
  geom_line() +
  geom_richtext(x = 10,
                mapping = aes(y = rdiv_sim$Med_sing + 0.50),
                size=4.5,
                label.color = NA,
                label = paste("RDiv^Med =",paste0(round(rdiv_sim$Med_sing,digits = 2))))

p_dd / p_rd / p_sign
```


# Response capacity


## Community 1 - Randomly selecting 3 species

```{r comm1, fig.cap='Response surfaces of the species composing community 1', fig.align="center", fig.height = 8, fig.width=20}

Ankistrodesmus_p <- filter(nested_gams, SpeciesName == "Ankistrodesmus")
Ankistrodesmus_p <- draw(Ankistrodesmus_p$gams[[1]], rug = FALSE, dist = 0.5) &
  labs(x = "temperature °C", y = "Phosphate (μmol L−1)",title = "Ankistrodesmus", caption = "")
Ankistrodesmus_p <- Ankistrodesmus_p +  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))
 
Chlamydomonas_p <- filter(nested_gams, SpeciesName == "Chlamydomonas")
Chlamydomonas_p <- draw(Chlamydomonas_p$gams[[1]], rug = FALSE, dist = 0.5) &
  labs(x = "temperature °C", y = "Phosphate (μmol L−1)",title = "Chlamydomonas", caption = "")
Chlamydomonas_p <- Chlamydomonas_p +  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))

Monoraphidium_p <- filter(nested_gams, SpeciesName == "Monoraphidium")
Monoraphidium_p <- draw(Monoraphidium_p$gams[[1]], rug = FALSE, dist = 0.5) &
  labs(x = "temperature °C", y = "Phosphate (μmol L−1)", title = "Monoraphidium", caption = "") 
Monoraphidium_p <- Monoraphidium_p +  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))

plot_community1 <- Ankistrodesmus_p + Chlamydomonas_p + Monoraphidium_p+
  plot_layout(ncol = 3)  # 3 plots in one row

# Print the combined plot
print(plot_community1)
```

```{r results='hide', warning=FALSE, message=FALSE}
library(viridis)
## community 1 
nested_gams1 <- nested_gams %>% filter(SpeciesName == c("Ankistrodesmus" , "Chlamydomonas", "Monoraphidium"))
#list of gams
m_list <- (nested_gams1$gams)
#list of spp names
my_spp_names <- (nested_gams1$SpeciesName)

#refs <- new_data
### Function 
get_partials <- function(m, refs) {
  refs$pd_E1 <- NA
  refs$pd_E2 <- NA
  for(i in 1:nrow(refs)) {
    refs$pd_E1[i] <- partial_derivatives(m,
                                        data = refs[i,],
                                        type = "central",
                                        focal = "E1")$partial_deriv
    refs$pd_E2[i] <- partial_derivatives(m,
                                        data = refs[i,],
                                        type = "central",
                                        focal = "E2")$partial_deriv
  }
  refs
}

refs1 <- crossing(E1 = seq(15, 40, length = 20),
                  E2 = seq(0.01, 30, length = 20))
# get partial derivatives
pd_list <- modify_depth(m_list, 1, ~ get_partials(., refs1))

# from list to tibble
pd_spp <- tibble(
  E1_ref = map(pd_list, "E1"),
  E2_ref = map(pd_list, "E2"),
  pd_E1 = map(pd_list, "pd_E1"),
  pd_E2 = map(pd_list, "pd_E2")) %>%
  dplyr::mutate(sp = my_spp_names) %>%
  relocate(sp, E1_ref, E2_ref, pd_E1, pd_E2) %>%
  unnest(E1_ref, E2_ref, pd_E1, pd_E2)



radius <- 1
num_arrows <- 1000

pd_spp <- tibble(angle = rep(seq(0, 2*pi, length = num_arrows), nrow(pd_spp))) %>%
  mutate(E1_ref = rep(pd_spp$E1_ref, each = num_arrows),
         E2_ref = rep(pd_spp$E2_ref, each = num_arrows)) %>%
  full_join(pd_spp) %>%
  mutate(E1 = cos(angle) * radius,
         E2 = sin(angle) * radius,
         dir_deriv = E1 * pd_E1 + E2 * pd_E2,
         unit_vec_mag = sqrt(E1^2 + E2^2))


# filter useless stuff
pd_spp <- pd_spp %>% 
  dplyr::select(angle, sp, E1_ref, E2_ref, dir_deriv)

#
# Calculating diversity for each direction and location this should be always the first step
# Dissimilarity
Div_loc_dir <- pd_spp %>% 
  dplyr::group_by(E1_ref, E2_ref, angle) %>% 
  summarise(div = resp_div(dir_deriv, sign = T))



RDiv <- tibble(Div_loc_dir %>% dplyr::group_by(E1_ref, E2_ref) %>% 
                 summarise(mean = mean(div)))



m_RD <- gam(mean ~ te(E1_ref, E2_ref, k = c(5, 5)),
            data = RDiv,
            method = "REML")


RDiv$predicted_mean <- predict(m_RD, newdata = RDiv, type = "response")
# Generate grid of E1_ref and E2_ref values
e1_values <- seq(min(RDiv$E1_ref), max(RDiv$E1_ref), length.out = 100)
e2_values <- seq(min(RDiv$E2_ref), max(RDiv$E2_ref), length.out = 100)
grid <- expand.grid(E1_ref = e1_values, E2_ref = e2_values)

# Predict mean values on the grid
grid$pred_mean <- predict(m_RD, newdata = grid, type = "response")
library(ggsci)

# Plot predicted surface with colored background and black contour lines
capacity_divergence1 <- ggplot(grid, aes(x = E1_ref, y = E2_ref, z = pred_mean, fill = pred_mean)) +
  geom_tile(aes(fill = pred_mean)) +
  geom_contour(color = "black", linetype = "solid") +
  scale_fill_viridis(option = "inferno", alpha = 0.85) +  # Use cm.colors palette with 100 colors
  labs(tag = "(a)",
       x = "Temperature °C", y = "Phosphate concentration (μmol L−1)", title = "Community 1", fill = "") +
  theme_classic() +
  theme(legend.position = "none") +
  theme(
    text = element_text(size = 30),  # Set the size of all text
    title = element_text(size = 30),  # Set the size of titles
    axis.title = element_text(size = 25),  # Set the size of axis titles
    axis.text = element_text(size = 25),  # Set the size of axis labels
    axis.ticks = element_line(size = 0.5),  # Set the size of axis ticks
    legend.title = element_text(size = 30),  # Set the size of legend title
    legend.text = element_text(size = 20),
    legend.key.size = unit(2.5, "lines"))  +
  theme(
    axis.text = element_text(color = "black"),  # Set axis text to black
    axis.ticks = element_line(color = "black")  # Set axis ticks to black
  )

```


## Community 2 - Randomly selecting 3 species

```{r comm2, fig.cap='Response surfaces of the species composing community 2', fig.align="center", fig.height = 8, fig.width=20}

Ankistrodesmus_p <- filter(nested_gams, SpeciesName == "Ankistrodesmus")
Ankistrodesmus_p <- draw(Ankistrodesmus_p$gams[[1]], rug = FALSE, dist = 0.5) &
  labs(x = "temperature °C", y = "Phosphate (μmol L−1)",title = "Ankistrodesmus", caption = "")
Ankistrodesmus_p <- Ankistrodesmus_p +  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))
 
Scenedesmus_p <- filter(nested_gams, SpeciesName == "Scenedesmus")
Scenedesmus_p <- draw(Scenedesmus_p$gams[[1]], rug = FALSE, dist = 0.5) &
  labs(x = "temperature °C", y = "Phosphate (μmol L−1)",title = "Scenedesmus", caption = "")
Scenedesmus_p <- Scenedesmus_p +  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))

Raphidocelis_p <- filter(nested_gams, SpeciesName == "Raphidocelis")
Raphidocelis_p <- draw(Raphidocelis_p$gams[[1]], rug = FALSE, dist = 0.5) &
  labs(x = "temperature °C", y = "Phosphate (μmol L−1)", title = "Raphidocelis", caption = "") 
Raphidocelis_p <- Raphidocelis_p +  guides(color="none" , fill=guide_colourbar(title="Growth \n Rate"))

plot_community2 <- Ankistrodesmus_p + Scenedesmus_p + Raphidocelis_p+
  plot_layout(ncol = 3)  # 3 plots in one row

# Print the combined plot
print(plot_community2)
```

```{r results='hide', warning=FALSE, message=FALSE}

## community 2 
nested_gams2 <- nested_gams %>% filter(SpeciesName %in% c("Ankistrodesmus", "Scenedesmus", "Raphidocelis"))
#list of gams
m_list <- (nested_gams2$gams)
#list of spp names
my_spp_names <- (nested_gams2$SpeciesName)

refs1 <- crossing(E1 = seq(15, 40, length = 20),
                  E2 = seq(0.01, 30, length = 20))
# get partial derivatives
pd_list <- modify_depth(m_list, 1, ~ get_partials(., refs1))

# from list to tibble
pd_spp <- tibble(
  E1_ref = map(pd_list, "E1"),
  E2_ref = map(pd_list, "E2"),
  pd_E1 = map(pd_list, "pd_E1"),
  pd_E2 = map(pd_list, "pd_E2")) %>%
  dplyr::mutate(sp = my_spp_names) %>%
  relocate(sp, E1_ref, E2_ref, pd_E1, pd_E2) %>%
  unnest(E1_ref, E2_ref, pd_E1, pd_E2)


radius <- 1
num_arrows <- 1000
pd_spp <- tibble(angle = rep(seq(0, 2*pi, length = num_arrows), nrow(pd_spp))) %>%
  mutate(E1_ref = rep(pd_spp$E1_ref, each = num_arrows),
         E2_ref = rep(pd_spp$E2_ref, each = num_arrows)) %>%
  full_join(pd_spp) %>%
  mutate(E1 = cos(angle) * radius,
         E2 = sin(angle) * radius,
         dir_deriv = E1 * pd_E1 + E2 * pd_E2,
         unit_vec_mag = sqrt(E1^2 + E2^2))


# filter useless stuff
pd_spp <- pd_spp %>% 
  dplyr::select(angle, sp, E1_ref, E2_ref, dir_deriv)

#
# Calculating diversity for each direction and location this should be always the first step
# Dissimilarity
Div_loc_dir <- pd_spp %>% 
  dplyr::group_by(E1_ref, E2_ref, angle) %>% 
  summarise(div = resp_div(dir_deriv, sign = T))



RDiv <- tibble(Div_loc_dir %>% dplyr::group_by(E1_ref, E2_ref) %>% 
                 summarise(mean = mean(div)))



m_RD <- gam(mean ~ te(E1_ref, E2_ref, k = c(5, 5)),
            data = RDiv,
            method = "REML")


RDiv$predicted_mean <- predict(m_RD, newdata = RDiv, type = "response")
# Generate grid of E1_ref and E2_ref values
e1_values <- seq(min(RDiv$E1_ref), max(RDiv$E1_ref), length.out = 100)
e2_values <- seq(min(RDiv$E2_ref), max(RDiv$E2_ref), length.out = 100)
grid <- expand.grid(E1_ref = e1_values, E2_ref = e2_values)

# Predict mean values on the grid
grid$pred_mean <- predict(m_RD, newdata = grid, type = "response")


# Plot predicted surface with colored background and black contour lines
capacity_divergence2 <- ggplot(grid, aes(x = E1_ref, y = E2_ref, z = pred_mean, fill = pred_mean)) +
  geom_tile(aes(fill = pred_mean)) +
  geom_contour(color = "black", linetype = "solid") +
  scale_fill_viridis(option = "inferno", alpha = 0.85) +  # Use cm.colors palette with 100 colors
  labs(tag = "(b)",
       x = "Temperature °C", y = "Phosphate concentration (μmol L−1)", title = "Community 2", fill = "") +
theme_classic() +
  theme(
    text = element_text(size = 30),  # Set the size of all text
    title = element_text(size = 30),  # Set the size of titles
    axis.title = element_text(size = 25),  # Set the size of axis titles
    axis.text = element_text(size = 25),  # Set the size of axis labels
    axis.ticks = element_line(size = 0.5),  # Set the size of axis ticks
    legend.title = element_text(size = 30),  # Set the size of legend title
    legend.text = element_text(size = 20),
    legend.key.size = unit(2.5, "lines")) +
  theme(
    axis.text = element_text(color = "black"),  # Set axis text to black
    axis.ticks = element_line(color = "black")  # Set axis ticks to black
  ) +
  theme( axis.title.y = element_blank(),
         axis.text.y = element_blank())  +  guides(color="none" , fill=guide_colourbar(title="Response \n Capacity"))

```

```{r ResponseCapcity, fig.cap='Response Capacity of (a) community 1 and (b) community 2.', fig.align="center", fig.height = 10, fig.width=16}
combined_plots <- capacity_divergence1 + capacity_divergence2
combined_plots
```


# Assessing uncertainty in GAM predictions

To assess the uncertainty associated with GAM predictions and determine the level of replication needed for robustness,
one can use posterior sampling.
Instead of resampling data (e.g. bootstrapping), one can sample from the posterior distribution of the model. One can either sample new fitted values or one can use the new data (predictions). There are functions in the package gratia to do this: fitted_samples(), predicted_samples(), and posterior_samples(), depending on what one is trying to compute or show the uncertainty of.
Here we want to show the uncertainty in the estimated GAM; for that fitted_samples() is sufficient.
We will then plot the predicted growth rate with the uncertainty, and compare those with the real / measured data, which help understand the variability in predictions and provide a qualitative assessment of the robustness of the GAMs.
More on posterior sampling can be found here: https://gavinsimpson.github.io/gratia/articles/posterior-simulation.html


We first show how it work for a specific subset of the model (i.e. model effect of temperature on one species for a specific phosphate concentration).
Then, we assess the uncertainty in the estimated GAMs for all species, all phosphate concentrations, and all temperature.

We use the function "fitted_values()". Posterior fitted values are draws from the posterior distribution of the mean or expected value of the response. These expectations are what is returned when you use predict() on an estimated GAM, except fitted_samples() includes the uncertainty in the estimated model coefficients, whereas predict() just uses the estimated coefficients.


One species.
```{r Uncert_sp, fig.cap='Predicted growth rate with the uncertainty vs Measurted values. Black dots are the measured values, and the blue line is the smooth on real data. Adding the posterior fitted samples to the plot of the data, superimposing the Bayesian credible interval on the fitted values we see the posterior draws are largely contained the credible interval.', fig.align="center", fig.height = 10, fig.width=8}
df_1 <- df %>%  filter(SpeciesName == "Ankistrodesmus") %>% 
  rename(E1 = temperature,
         E2 = Phosphate_concentration) 

plt <-  df_1%>% filter(E2 == 2) %>% 
  ggplot( aes(x = E1, y = (mumax))) +
  geom_point()+
  geom_smooth(se = FALSE) +
  facet_wrap(~SpeciesName) +
  theme_bw(base_size = 20)+
  labs(x = "Temperature °C", y = "growth rate", tag = "(a)")


m <- nested_gams$gams[[1]]

new_df <- data_slice(m, E1 = evenly(E1, n = 200)) |>
  mutate(.row = row_number())

fv <- fitted_values(m, data = new_df)

fs <- fitted_samples(m, data = new_df, n = 10, seed = 4) |>
  left_join(new_df |> select(.row, E1), by = join_by(row == .row))



plt +
geom_ribbon(data = fv, aes(y = fitted, ymin = lower, ymax = upper),
            fill = "red", alpha = 0.3) +
  geom_line(data = fs, aes(group = draw, x = E1, y = fitted),
            colour = "yellow", alpha = 0.4)
```

All species.
```{r echo=FALSE, warning=FALSE}

# Initialize lists to store fitted values and samples for all species
all_combined_fitted_values <- list()
all_combined_fitted_samples <- list()

# Loop through each species in nested_gams
for (species_index in seq_along(nested_gams$gams)) {
  
  # Extract the species name and model
  selected_species <- nested_gams$SpeciesName[species_index]
  m <- nested_gams$gams[[species_index]]
  
  # Prepare the DataFrame for the current species
  df_species <- df %>% 
    filter(SpeciesName == selected_species) %>% 
    rename(E1 = temperature, E2 = Phosphate_concentration)
  
  # Extract unique E2 values for the current species
  e2_values <- df_species %>%
    pull(E2) %>%
    unique()
  
  # Initialize lists to store fitted values and samples for the current species
  all_fitted_values <- list()
  all_fitted_samples <- list()
  
  # Loop through each E2 value to get fitted values and samples
  for (e2_value in e2_values) {
    
    # Create a new data frame for the current E2 value
    new_df <- data_slice(m, E1 = evenly(E1, n = 40)) %>%
      mutate(E2 = e2_value) %>%
      mutate(.row = row_number())
    
    # Get fitted values for the GAM model
    fv <- fitted_values(m, data = new_df)
    
    # Get fitted samples for the GAM model
    fs <- fitted_samples(m, data = new_df, n = 10, seed = 4) %>%
      left_join(new_df |> select(.row, E1), by = join_by(row == .row)) %>%
      mutate(E2 = e2_value)  # Add the current E2 value to the samples
    
    # Store results
    all_fitted_values[[as.character(e2_value)]] <- fv
    all_fitted_samples[[as.character(e2_value)]] <- fs
  }
  
  # Combine all fitted values and samples into data frames for the current species
  combined_fitted_values <- bind_rows(all_fitted_values, .id = "E2") %>%
    mutate(SpeciesName = selected_species)
  
  combined_fitted_samples <- bind_rows(all_fitted_samples, .id = "E2") %>%
    mutate(SpeciesName = selected_species)
  
  # Append to the overall lists
  all_combined_fitted_values[[selected_species]] <- combined_fitted_values
  all_combined_fitted_samples[[selected_species]] <- combined_fitted_samples
}

# Combine all fitted values and samples across species
final_combined_fitted_values <- bind_rows(all_combined_fitted_values)
final_combined_fitted_samples <- bind_rows(all_combined_fitted_samples)



# Define the manual order for E2 values
manual_order <- c(0.01, 0.1, 0.5, 1, 2, 4, 6, 8, 10, 20, 30, 40)

# Set E2 as an ordered factor based on the manual order
final_combined_fitted_values <- final_combined_fitted_values %>%
  mutate(E2 = factor(E2, levels = manual_order, ordered = TRUE))

# Create the fitted sample plot
fitted_sample_plot <- ggplot(final_combined_fitted_values, 
                             aes(x = .row, y = fitted, color = E2)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = E2), alpha = 0.2) +
  labs(title = "Fitted Samples Across Phosphate Values for All Species",
       x = "Temperature",
       y = "Fitted Samples", 
       color = "Phosphate",
       fill = "Phosphate") +
  theme_minimal(base_size = 25) +
  facet_wrap(~ SpeciesName, ncol = 5) +
  scale_color_viridis_d(end = 0.2, begin = 0.9, option = 'inferno') +
  scale_fill_viridis_d(end = 0.2, begin = 0.9, option = 'inferno') +
  scale_y_continuous(limits = c(0, 3), breaks = seq(-0.5, 3, by = 0.5))+
  theme(legend.position = "bottom")




df2 <- df %>% 
  rename(E1 = temperature, E2 = Phosphate_concentration)
# Base plot with original data points and smoothed line
plt <- df2 %>% 
  ggplot(aes(x = E1, y = mumax, col = as.factor(E2))) +
  geom_point() +
  geom_smooth(se = FALSE) +
  theme_minimal(base_size = 25) +
  labs(x = "Temperature", y = "Growth Rate", 
       color = "Phosphate") +
  facet_wrap(~ SpeciesName, ncol = 5) +
  scale_color_viridis_d(end = 0.2, begin = 0.9, option = 'inferno') +
  scale_fill_viridis_d(end = 0.2, begin = 0.9, option = 'inferno') +
  theme(legend.position = "bottom")+
  scale_y_continuous(limits = c(0, 3), breaks = seq(-0.5, 3, by = 0.5))  # Specify y-axis limits and breaks



```


```{r Uncert1, fig.cap='Predicted growth rate with the uncertainty vs Measured values. Respose curves along the temperature gradient.', fig.align="center", fig.height = 15, fig.width=18}
plt / fitted_sample_plot

```

```{r echo=FALSE, warning=FALSE}
#### E1
# Initialize lists to store fitted values and samples for all species
all_combined_fitted_values <- list()
all_combined_fitted_samples <- list()

# Loop through each species in nested_gams
for (species_index in seq_along(nested_gams$gams)) {
  
  # Extract the species name and model
  selected_species <- nested_gams$SpeciesName[species_index]
  m <- nested_gams$gams[[species_index]]
  
  # Prepare the DataFrame for the current species
  df_species <- df %>% 
    filter(SpeciesName == selected_species) %>% 
    rename(E1 = temperature, E2 = Phosphate_concentration)
  
  # Extract unique E2 values for the current species
  e1_values <- df_species %>%
    pull(E1) %>%
    unique()
  
  # Initialize lists to store fitted values and samples for the current species
  all_fitted_values <- list()
  all_fitted_samples <- list()
  
  # Loop through each E2 value to get fitted values and samples
  for (e1_value in e1_values) {
    
    # Create a new data frame for the current E2 value
    new_df <- data_slice(m, E2 = evenly(E2, n = 40)) %>%
      mutate(E1 = e1_value) %>%
      mutate(.row = row_number())
    
    # Get fitted values for the GAM model
    fv <- fitted_values(m, data = new_df)
    
    # Get fitted samples for the GAM model
    fs <- fitted_samples(m, data = new_df, n = 10, seed = 4) %>%
      left_join(new_df |> select(.row, E2), by = join_by(row == .row)) %>%
      mutate(E2 = e1_value)  # Add the current E2 value to the samples
    
    # Store results
    all_fitted_values[[as.character(e1_value)]] <- fv
    all_fitted_samples[[as.character(e1_value)]] <- fs
  }
  
  # Combine all fitted values and samples into data frames for the current species
  combined_fitted_values <- bind_rows(all_fitted_values, .id = "E1") %>%
    mutate(SpeciesName = selected_species)
  
  combined_fitted_samples <- bind_rows(all_fitted_samples, .id = "E1") %>%
    mutate(SpeciesName = selected_species)
  
  # Append to the overall lists
  all_combined_fitted_values[[selected_species]] <- combined_fitted_values
  all_combined_fitted_samples[[selected_species]] <- combined_fitted_samples
}

# Combine all fitted values and samples across species
final_combined_fitted_values <- bind_rows(all_combined_fitted_values)
final_combined_fitted_samples <- bind_rows(all_combined_fitted_samples)



# Plotting the fitted values for all species
fitted_value_plot <- ggplot(final_combined_fitted_values, 
                            aes(x = .row, y = fitted, color = as.factor(E1), group = interaction(SpeciesName, E1))) +
  geom_line() +
  labs(title = "Fitted Values Across E1 Values for All Species",
       x = "Observation Index",
       y = "Fitted Values") +
  theme_minimal() +
  facet_wrap(~ SpeciesName, scales = "free_y")




# Create the fitted sample plot
fitted_sample_plot <- ggplot(final_combined_fitted_values, 
                             aes(x = .row, y = fitted, color = as.factor(E1))) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = as.factor(E1)), alpha = 0.2) +
  labs(title = "Fitted Samples Across Temperature Values for All Species",
       x = "Phosphate concentration",
       y = "Fitted Samples", 
       color = "Temperature",
       fill = "Temperature") +
  theme_minimal(base_size = 25) +
  facet_wrap(~ SpeciesName, ncol = 5) +
  scale_color_viridis_d(end = 0.2, begin = 0.9, option = 'inferno') +
  scale_fill_viridis_d(end = 0.2, begin = 0.9, option = 'inferno') +
  scale_y_continuous(limits = c(0, 3), breaks = seq(0, 3, by = 0.5))+
  theme(legend.position = "bottom")






df2 <- df %>% 
  rename(E1 = temperature, E2 = Phosphate_concentration)
# Base plot with original data points and smoothed line
plt <- df2 %>% 
  ggplot(aes(x = E2, y = mumax, col = as.factor(E1))) +
  geom_point() +
  geom_smooth(se = FALSE) +
  theme_minimal(base_size = 25) +
  labs(title = "Measured values", x = "Phosphate", y = "Growth Rate", 
       color = "Temperature") +
  facet_wrap(~ SpeciesName, ncol = 5) +
  scale_color_viridis_d(end = 0.2, begin = 0.9, option = 'inferno') +
  scale_fill_viridis_d(end = 0.2, begin = 0.9, option = 'inferno') +
  theme(legend.position = "bottom", 
        legend.box = "horizontal") + 
  scale_y_continuous(limits = c(0, 3), breaks = seq(0, 3, by = 0.5))  # Specify y-axis limits and breaks




```

```{r Uncert2, fig.cap='Predicted growth rate with the uncertainty vs Measured values. Respose curves along the phosphate gradient.', fig.align="center", fig.height = 15, fig.width=18}
plt / fitted_sample_plot
```


We can see that the posterior draws are largely contained the credible interval.

```{r}
save.image(file = here("Data/Empirical_example.RData"))
```

